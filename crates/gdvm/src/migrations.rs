use crate::{eprintln_i18n, i18n::I18n};
use anyhow::Result;
use std::fs;
#[cfg(target_family = "unix")]
use std::os::unix::fs::PermissionsExt;
use std::path::Path;

#[cfg(target_os = "windows")]
const GDVM_SHIM: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/shim.exe"));
#[cfg(not(target_os = "windows"))]
const GDVM_SHIM: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/shim"));

const HEADER: &str = "## DO NOT EDIT THIS FILE! ##\n\
## THIS FILE IS AUTOMATICALLY MANAGED BY GDVM. ##\n\
## EDITING IT CAN BREAK YOUR GDVM CONFIGURATION ##\n";

type MigrationFn = fn(&Path, &I18n) -> Result<()>;

struct Migration {
    version: u32,
    run: MigrationFn,
}

macro_rules! define_migrations {
    ( $( $ver:literal => |$path:ident, $i18n:ident| $body:block ),* $(,)? ) => {
        const MIGRATIONS: &[Migration] = &[
            $( Migration { version: $ver, run: |$path, $i18n| -> Result<()> { $body } }, )*
        ];
    };
}

define_migrations! {
    1 => |base_path, i18n| {
        let bin_path = base_path.join("bin");

        fs::create_dir_all(&bin_path)?;

        let targets: &[&str] = if cfg!(target_os = "windows") {
            &["godot.exe", "godot_console.exe"]
        } else {
            &["godot"]
        };

        for exe in targets {
            let exe_path = bin_path.join(exe);
            if let Err(err) = write_bytes_if_different(GDVM_SHIM, &exe_path, Some(0o755)) {
                eprintln_i18n!(
                    i18n,
                    "error-ensure-godot-binaries-failed",
                    error = &err.to_string(),
                    path = &exe_path.to_string_lossy().to_string(),
                );
                return Err(err);
            }
        }

        Ok(())
    }
}

pub fn run_migrations(base_path: &Path, i18n: &I18n) -> Result<()> {
    fs::create_dir_all(base_path)?;

    let version_file = base_path.join("data_version");
    let original_version = read_data_version(&version_file)?;
    let mut current = original_version;

    for mig in MIGRATIONS {
        if current < mig.version {
            (mig.run)(base_path, i18n)?;
            current = mig.version;
        }
    }

    if original_version == current {
        return Ok(());
    }

    write_data_version(&version_file, current)?;

    Ok(())
}

fn read_data_version(path: &Path) -> Result<u32> {
    if !path.exists() {
        return Ok(0);
    }

    let contents = fs::read_to_string(path)?;

    for line in contents.lines() {
        let trimmed = line.trim();

        if trimmed.starts_with('#') || trimmed.is_empty() {
            continue;
        }

        if let Ok(v) = trimmed.parse::<u32>() {
            return Ok(v);
        }
    }
    Ok(0)
}

fn write_data_version(path: &Path, version: u32) -> Result<()> {
    let content = format!("{}{}\n", HEADER, version);

    fs::write(path, content)?;

    Ok(())
}

fn write_bytes_if_different(bytes: &[u8], dest: &Path, perm: Option<u32>) -> Result<()> {
    #[cfg(not(target_family = "unix"))]
    let _ = perm;

    let write_bytes = || -> Result<()> {
        fs::write(dest, bytes)?;

        #[cfg(target_family = "unix")]
        if let Some(mode) = perm {
            fs::set_permissions(dest, fs::Permissions::from_mode(mode))?;
        }

        Ok(())
    };

    if let Ok(metadata) = fs::metadata(dest) {
        if metadata.len() != bytes.len() as u64 {
            write_bytes()?;
        }
    } else {
        write_bytes()?;
    }

    let file = fs::File::open(dest)?;
    let mut reader = std::io::BufReader::new(file);
    let mut idx = 0;
    let mut buffer = [0u8; 8192];

    loop {
        let read = std::io::Read::read(&mut reader, &mut buffer)?;

        if read == 0 {
            break;
        }

        if buffer[..read] != bytes[idx..idx + read] {
            write_bytes()?;
            return Ok(());
        }

        idx += read;
    }

    Ok(())
}
